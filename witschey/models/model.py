from __future__ import division, print_function

# all adapted from Dr. Tim Menzies' model code:
# https://github.com/timm/sbse14/blob/master/models.py

from abc import ABCMeta
from collections import namedtuple
from random import sample

from witschey import basic_stats

ModelIO = namedtuple('ModelIO', ('xs', 'ys', 'energy'))


class Model(object):
    # allows us to get all subclasses with __subclasses__()
    __metaclass__ = ABCMeta

    def __init__(self, independents=None, dependents=None,
                 energy_min=None, energy_max=None):
        if independents is None or dependents is None:
            raise ValueError

        self.xs = independents
        self.ys = dependents
        self.energy_max = energy_max
        self.energy_min = energy_min

    def normalize(self, x):
        return basic_stats.norm(x, self.energy_max, self.energy_min)

    def random_input_vector(self):
        return tuple(x() for x in self.xs)

    def __call__(self, xs, io=False):
        for i, x in enumerate(xs):
            if not self.xs[i].valid(x):
                raise ModelInputException

        ys = tuple(y(xs) for y in self.ys)
        energy = sum(ys)

        if self.energy_min is None or self.energy_min > energy:
            self.energy_min = energy

        if self.energy_max is None or energy > self.energy_max:
            self.energy_max = energy

        if io:
            return ModelIO(xs, ys, energy)

        return ys

    def energy(self, ys, norm=False):
        rv = sum(ys)
        return self.normalize(rv) if norm else rv

    def compute_model_io(self, xs):
        """
        Return a ModelIO namedtuple containing the input provided as the
        argument, the output values for each function, and the energy of that
        output.

        Since this evaluates the model on its input, this method may raise a
        ModelInputException.
        """
        ys = self(xs)
        return ModelIO(xs, ys, self.energy(ys))

    def random_model_io(self):
        """
        Generate a random input for this model, then run the model
        """
        while True:
            try:
                return self.compute_model_io(self.random_input_vector())
            except ModelInputException:
                pass

    def random_replace(self, xs, n=1):
        """
        Returns a tuple identical to xs, except in n positions, where the
        value has been replaced with a value randomly generated by the
        appropriate independent variable.

        >>> from independent_variable import IndependentVariable as IV
        >>> import random;
        >>> random.seed(1)
        >>> ivs = tuple(IV(0, 10) for _ in range(3))
        >>> m = Model(independents=ivs, dependents=())
        >>> m.random_replace((5, 5, 5))
        (8.474337369372327, 5, 5)
        >>> m.random_replace((5, 5, 5), 2)
        (4.954350870919409, 5, 4.494910647887381)
        """
        replace_indices = sample(tuple(range(len(xs))), n)
        return tuple(self.xs[i]() if i in replace_indices else x
                     for i, x in enumerate(xs))


class ModelInputException(Exception):
    pass
